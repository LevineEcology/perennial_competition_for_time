##---------------------------------------------------------------
## WATER_ONLY_SIMULATOR -- eq_functions.jl
##
## By: Jacob Levine -- jacoblevine@princeton.edu
## November 2022
##---------------------------------------------------------------

"""
    feas(sd::DataFrame, F::Float64 = F, E::Float64 = E, W₀::Float64 = 0.6)

Use convex hull algorithm to determine the feasibility of each species in `sd`. `sd` should be a `DataFrame`
as generated by `generate_spp_data()`. Returns a vector of indices giving the subset of species identifiers
in `sd` which are feasible given their break-even time and critical water content.
"""
function feas(sd::DataFrame, F::Float64 = F, E::Float64 = E, W₀::Float64 = 0.6)

    points = [Vector{Float64}(undef,2) for _ in 1:(nrow(sd)+1)]
    for s in [1:1:nrow(sd);]
        points[s] =  Array(sd[s,[:τ,:Wᵢ]])
    end
    points[nrow(sd)+1] = [0, W₀]
    hull = convex_hull(points)

    lower_hull = Any[]
    for i in [2:1:length(hull);]
        if hull[i][2] < hull[i-1][2]
            push!(lower_hull, hull[i])
        else
        end
    end

    coex = Any[]
    for i in [1:1:length(points)-1;]
        if points[i] in lower_hull
            push!(coex, i)
        end
    end

    coex[sd[coex,:Wᵢ] .< W₀]

end;


"""
    calc_eqN(sd::DataFrame, F::Float64 = F, E::Float64 = E, W₀::Float64 = 0.6)

TBW
"""
function calc_eqN(sd::DataFrame, F::Float64 = F, E::Float64 = E, W₀::Float64 = 0.6)
    output = Vector{Int64}(undef, nrow(sd))
    eqN = Vector{Float64}(undef, nrow(sd))
    sd = sort(sd, :Wᵢ, rev = true)
    sg = sigma(μ, l, b)

    fs = feas(sd, F, E, W₀)
    eqN[(!in).(sd.spp,Ref(fs))] .= 0

    if length(fs) == 1
                eqN[fs[1]] = (sg*(F^((b-1)/b) / E)) * ((W₀ - sd[fs[1],:Wᵢ])/(sd[fs[1],:τ]))
    else
        for s in [1:1:length(fs);]
            if s == 1
                eqN[fs[s]] = (sg*(F^((b-1)/b) / E)) * ((W₀ - sd[fs[s],:Wᵢ])/(sd[fs[s],:τ]) - ((sd[fs[s],:Wᵢ] - sd[fs[s+1],:Wᵢ]) / (sd[fs[s+1],:τ] - sd[fs[s],:τ])))
            elseif s == length(fs)
                eqN[fs[s]] = sg*(F^((b-1)/b) / (E)) * ((sd[fs[s-1],:Wᵢ] - sd[fs[s],:Wᵢ])/(sd[fs[s],:τ] - sd[fs[s-1], :τ]))
            else
                eqN[fs[s]] = sg*(F^((b-1)/b) / (E)) * (((sd[fs[s-1],:Wᵢ] - sd[fs[s],:Wᵢ])/(sd[fs[s],:τ]-sd[fs[s-1],:τ])) - ((sd[fs[s],:Wᵢ] - sd[fs[s+1],:Wᵢ])/(sd[fs[s+1],:τ]-sd[fs[s],:τ])))
            end
        end
    end

    sd.eqN = eqN
    output = sort(sd, :spp)
    return output
end;

"""
    check_eq(bd, tol = 1e-15)

TBW
"""
function check_eq(bd, tol = 1e-15)
    check = (Array(bd[nrow(bd),[2:1:ncol(bd);]]) .-
        Array(bd[nrow(bd)-1,[2:1:ncol(bd);]])) ./
        Array(bd[nrow(bd)-1,[2:1:ncol(bd);]])
    if all(check[.!isnan.(check)] .< tol)
        return true
    else return false
    end
end;

"""
    plot_eq_agreement(data::DataFrame, save::Bool = false, filename::String = "")

TBW
"""
function plot_eq_agreement(data::DataFrame, save::Bool = false, filename::String = "")
   p = plot(framestyle = :box, grid = false,
            legend = :none, ylab = "Equilibrium density (simulated)", xlab = "Equilibrium density (predicted)",
            ylim = [0, maximum(data.eq_an)+10], xlim = [0, maximum(data.eq_an)+10])
   p = Plots.abline!(1,0)
   p = plot!(data.eq_an, data.eq_sim, seriestype = "scatter")
   if save
       savefig(filename)
   end
   return p
end

"""
    check_eq_agreement(iter::Int64, Nspp::Int64, Nyr::Int64 = 2000,
                            W0::Float64 = 0.6)

TBW
"""
function check_eq_agreement(iter::Int64, Nspp::Int64, Nyr::Int64 = 2000,
                            W₀::Float64 = 0.6)
    eq_sim = Vector{Float64}(undef, iter*Nspp)
    eq_an = Vector{Float64}(undef, iter*Nspp)
    Threads.@threads for i in 1:iter
        spp_data = generate_spp_data(Nspp, W₀)
        eq_sim[[((i-1)*Nspp)+1:1:i*Nspp;]] = Vector(sim_water_only(spp_data, Nyr, Nspp, Ninit)[3][Nyr+1,2:Nspp+1])
        eq_an[[((i-1)*Nspp)+1:1:i*Nspp;]] = calc_eqN(spp_data, F, E, W₀)[:,:eqN]
    end
    return DataFrame(eq_sim = eq_sim, eq_an = eq_an)
end;
