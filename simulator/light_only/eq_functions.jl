##---------------------------------------------------------------
## WATER_ONLY_SIMULATOR -- eq_functions.jl
##
## By: Jacob Levine -- jacoblevine@princeton.edu
## November 2022
##---------------------------------------------------------------

## calculates the minimum feasible growth rate
function minfeas(μ::Float64 = 0.1, F::Float64 = 1.0, b::Float64 = 2.5, analytical = false)

    if analytical
        s = gamma(b+1, 0.0) * μ^-(b+1)
    else
        s = sigma(μ, b)
    end

   (1/(F * s))^(1/b)
end

function μ_feas(spp_data::DataFrame, F::Float64, μ::Float64, analytical = false)
    mf = minfeas(μ, F, b, analytical)
    findall(spp_data.C₁ .> mf)
end

"""
    feas(sd::DataFrame, F::Float64 = F, E::Float64 = E, W₀::Float64 = 0.6)

Use convex hull algorithm to determine the feasibility of each species in `sd`. `sd` should be a `DataFrame`
as generated by `generate_spp_data()`. Returns a vector of indices giving the subset of species identifiers
in `sd` which are feasible given their break-even time and critical water content.
"""

function feas(sd::DataFrame, W₀::Float64 = 0.6,
              F::Float64 = 10.0, μ::Float64 = 0.1, analytical = false)

    infeas = μ_feas(sd, F, μ, analytical)
    first_feas = minimum(findall(sd.Wᵢ .< W₀), init = 9999)
    if first_feas == 9999
        return []
    else

        points = DataFrame(τ = vcat(sd.τ[infeas], 0.0), Wᵢ = vcat(sd.Wᵢ[infeas], W₀), spp = vcat(sd.spp[infeas], 0))
        sort!(points, :Wᵢ, rev = true)

        points = points[first_feas:nrow(points), :]
        if nrow(points) == 1
            return []
        else

            coex = []
            e = 1
            while e < nrow(points)-1
                points.slope .= (points.Wᵢ[e] .- points.Wᵢ) ./ (points.τ[e] .- points.τ)
                cand = points.slope[e+1:nrow(points)]
                k = findall(points.slope .== minimum(cand[cand .< 0.0]))[1]
                if k == nrow(points)
                    break
                else
                    push!(coex, points[k,:spp])
                    e = k
                end
            end
            push!(coex, points[nrow(points),:spp])

            return coex[sd[coex,:Wᵢ] .< W₀]

        end

    end

end;

"""
    calc_eqN(sd::DataFrame, F::Float64 = F, E::Float64 = E, W₀::Float64 = 0.6)

TBW
"""
function calc_eqN(sd::DataFrame, F::Float64 = F, E::Float64 = E, W₀::Float64 = 0.6,
                  θ_fc::Float64 = 0.4, μ::Float64 = 0.1, T::Float64 = 0.1, P::Int64 = 10, analytical = false)
    output = Vector{Int64}(undef, nrow(sd))
    eqN = Vector{Float64}(undef, nrow(sd))
    sd = sort(sd, :Wᵢ, rev = true)

    if W₀ > θ_fc
        W₀ = θ_fc
    end

    fs = feas(sd, W₀, F, μ, analytical)
    if isempty(fs)
        sd.eqN .= 0.0
    else

        eqN[(!in).(sd.spp, Ref(fs))] .= 0.0

    if analytical

        cnst = (F * gamma(b + 1, 0.0))^((b - 1) / b) / (μ * E * μ^(1 / b) * gamma(b, 0.0))

        if length(fs) == 1
            eqN[fs[1]] = cnst * ((W₀ - sd[fs[1], :Wᵢ]) / (sd[fs[1], :τ]))
        else
            for s in [1:1:length(fs);]
                if s == 1
                    eqN[fs[s]] = cnst * ((W₀ - sd[fs[s], :Wᵢ]) / (sd[fs[s], :τ]) -
                                         (sd[fs[s], :Wᵢ] - sd[fs[s+1], :Wᵢ]) / (sd[fs[s+1], :τ] - sd[fs[s], :τ]))
                elseif s == length(fs)
                    eqN[fs[s]] = cnst * ((sd[fs[s-1], :Wᵢ] - sd[fs[s], :Wᵢ]) / (sd[fs[s], :τ] - sd[fs[s-1], :τ]))
                else
                    eqN[fs[s]] = cnst * (((sd[fs[s-1], :Wᵢ] - sd[fs[s], :Wᵢ]) / (sd[fs[s], :τ] - sd[fs[s-1], :τ])) -
                                         ((sd[fs[s], :Wᵢ] - sd[fs[s+1], :Wᵢ]) / (sd[fs[s+1], :τ] - sd[fs[s], :τ])))
                end
            end
        end

        else

            cnst = (exp(μ * T) / (exp(μ * T) - 1)) * (sigma(μ * T, b) * F * T)^((b - 1) / b) / (E * sigma(μ * T, b - 1))

            if length(fs) == 1
                eqN[fs[1]] = cnst * ((W₀ - sd[fs[1], :Wᵢ]) / (sd[fs[1], :τ]))
            else
                for s in [1:1:length(fs);]
                    if s == 1
                        eqN[fs[s]] = cnst * ((W₀ - sd[fs[s], :Wᵢ]) / (sd[fs[s], :τ]) -
                                             (sd[fs[s], :Wᵢ] - sd[fs[s+1], :Wᵢ]) / (sd[fs[s+1], :τ] - sd[fs[s], :τ]))
                    elseif s == length(fs)
                        eqN[fs[s]] = cnst * ((sd[fs[s-1], :Wᵢ] - sd[fs[s], :Wᵢ]) / (sd[fs[s], :τ] - sd[fs[s-1], :τ]))
                    else
                        eqN[fs[s]] = cnst * (((sd[fs[s-1], :Wᵢ] - sd[fs[s], :Wᵢ]) / (sd[fs[s], :τ] - sd[fs[s-1], :τ])) -
                                             ((sd[fs[s], :Wᵢ] - sd[fs[s+1], :Wᵢ]) / (sd[fs[s+1], :τ] - sd[fs[s], :τ])))
                    end
                end
            end

        end

        sd.eqN = eqN
    end

    output = sort(sd, :spp)
    return output

end;


"""
    check_eq(bd, tol = 1e-15)

TBW
"""
function check_eq(bd, tol = 1e-15)
    check = (Array(bd[nrow(bd),[2:1:ncol(bd);]]) .-
        Array(bd[nrow(bd)-1,[2:1:ncol(bd);]])) ./
        Array(bd[nrow(bd)-1,[2:1:ncol(bd);]])
    if all(check[.!isnan.(check)] .< tol)
        return true
    else return false
    end
end;

"""
    check_eq_agreement(iter::Int64, Nspp::Int64, Nyr::Int64 = 2000,
                            W0::Float64 = 0.6)

TBW
"""
function check_eq_agreement(iter::Int64, Nspp::Int64, Nyr::Int64 = 2000, θ_fc::Float64 = 0.4,
                            P::Int64 = 10, mean_p::Float64 = 16.0,
                            μ::Float64 = 0.15, F::Float64 = 10.0)
    eq_sim = Vector{Float64}(undef, iter*Nspp)
    eq_an = Vector{Float64}(undef, iter*Nspp)
    Threads.@threads for i in 1:iter
        spp_data = generate_spp_data(Nspp, 0.6, 1.0/P, F, μ, 2.5, 0.05, 0.0)
        eq_sim[[((i-1)*Nspp)+1:1:i*Nspp;]] =
            Vector(sim_water_only(spp_data, Nyr, Nspp, Ninit, μ, F, P, mean_p, θ_fc)[2][Nyr,2:Nspp+1])
        eq_an[[((i-1)*Nspp)+1:1:i*Nspp;]] =
            calc_eqN(spp_data, F, E, mean_p / P, θ_fc, μ, 1.0/P, P, false)[:,:eqN]
    end
    return DataFrame(eq_sim = eq_sim, eq_an = eq_an)
end;

"""
    plot_eq_agreement(data::DataFrame, save::Bool = false, filename::String = "")

TBW
"""
function plot_eq_agreement(data::DataFrame, save::Bool = false, filename::String = "")
   p = plot(framestyle = :box, grid = false,
            legend = :none, ylab = "Equilibrium density (simulated)", xlab = "Equilibrium density (predicted)",
            ylim = [0, maximum(data.eq_sim)], xlim = [0, maximum(data.eq_an)])
   p = Plots.abline!(1,0)
   p = plot!(data.eq_an, data.eq_sim, seriestype = "scatter")
   if save
       savefig(filename)
   end
   return p
end
